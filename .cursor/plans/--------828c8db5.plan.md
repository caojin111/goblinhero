<!-- 828c8db5-ddd2-4816-90aa-deff064593f8 f8dcfd1d-ea88-4226-8ae2-150a16e724c5 -->
# 挖矿掷骰子玩法改造计划

## 核心改动概述

将游戏从"旋转老虎机"改为"掷骰子挖矿"玩法：

- 棋盘初始被矿石覆盖
- 掷骰子（1-6）决定挖开的格子数量
- 只计算本次挖出格子的积分
- 阶段内保持挖开状态，阶段结束后重置

## 改动文件清单

### 1. Models/GameModels.swift

**改动内容：**

- 在`SlotCell`结构体中添加`isMined: Bool`属性（标记是否已挖开）
- 保持现有的`symbol`属性用于存储矿石下的符号

**代码位置：** 第110-114行

### 2. ViewModels/GameViewModel.swift

**核心逻辑改动：**

#### a. 添加新属性

```swift
@Published var diceResult: Int = 0  // 骰子结果
@Published var currentRoundMinedCells: [Int] = []  // 本次挖到的格子索引
```

#### b. 修改游戏流程方法

**`spin()` → `rollDice()`**

- 重命名并修改为掷骰子逻辑
- 生成1-6随机数
- 调用挖矿方法
- 计算本次挖矿收益
- 位置：第89-120行

**新增 `mineRandomCells(count: Int)`**

- 在未挖开的格子中随机选择count个
- 标记为已挖开（isMined = true）
- 记录本次挖到的格子索引

**修改 `generateSlotResults()`**

- 改为在回合开始时调用一次
- 为所有格子生成符号（或空格）
- 所有格子初始状态为isMined = false（被矿石覆盖）
- 位置：第122-157行

**修改 `calculateEarnings()`**

- 只计算`currentRoundMinedCells`中的格子
- 空格子+1分
- 有符号按baseValue和adjacentSymbols计算
- 位置：第192-222行

**新增 `resetMineState()`**

- 重置所有格子的isMined状态为false
- 在进入新阶段时调用（符号选择后）

#### c. 修改现有方法

**`startNewGame()`**

- 初始化棋盘时生成符号
- 所有格子设为未挖开状态
- 位置：第62-81行

**`selectSymbol()`**

- 选择符号后生成新的棋盘符号
- 重置矿石状态
- 位置：第271-280行

**`manualSpin()` → `rollDiceManually()`**

- 重命名为掷骰子
- 位置：第282-288行

### 3. Views/GameView.swift

**UI改动：**

#### a. SlotCellView（第180-233行）

**显示逻辑：**

- 如果`!cell.isMined`：显示矿石覆盖（🪨图标）
- 如果`cell.isMined && cell.symbol != nil`：显示符号
- 如果`cell.isMined && cell.symbol == nil`：显示空格子

**视觉效果：**

- 矿石状态：灰色背景 + 🪨图标
- 挖开动画：使用scale和opacity动画

#### b. ControlPanel（第235-305行）

**按钮改动：**

- 将"挖矿 x1"改为"掷骰子 🎲"
- 显示上次骰子结果（如果有）
- 按钮文案：`掷骰子（1-6）`

**新增骰子结果显示：**

- 在按钮上方显示本次骰子点数
- 动画效果：骰子滚动动画

#### c. 新增组件：DiceResultView

**显示内容：**

- 骰子点数
- "本次挖开X个格子"
- 本次获得积分

### 4. Config/GameConfig.json

**可能需要调整：**

- 初始旋转次数可能需要调整（因为改成掷骰子了）
- 保持现有配置，后续根据测试调整

## 实现步骤

### Step 1: 修改数据模型

- 在`SlotCell`添加`isMined`属性

### Step 2: 修改ViewModel核心逻辑

- 添加新属性（diceResult, currentRoundMinedCells）
- 修改生成符号逻辑（回合开始时生成）
- 实现掷骰子方法
- 实现随机挖矿方法
- 修改积分计算方法
- 添加重置矿石状态方法

### Step 3: 修改UI显示

- 更新SlotCellView显示矿石状态
- 修改控制按钮为掷骰子按钮
- 添加骰子结果显示
- 添加挖开动画效果

### Step 4: 测试验证

- 测试掷骰子随机性（1-6）
- 测试挖矿逻辑（不重复挖同一格子）
- 测试积分计算（空格+1，符号按值累加）
- 测试阶段切换（矿石重置）

## 关键技术点

1. **随机挖矿算法**
```swift
let unminedIndices = slotMachine.enumerated()
    .filter { !$0.element.isMined }
    .map { $0.offset }
let selected = unminedIndices.shuffled().prefix(count)
```

2. **矿石状态管理**

- 使用`isMined`布尔值
- 在选择符号后重置
- 在回合内保持

3. **积分计算**
```swift
for index in currentRoundMinedCells {
    if cell.symbol == nil {
        earnings += 1  // 空格
    } else {
        earnings += symbol.calculateValue(...)
    }
}
```

4. **UI动画**

- 骰子滚动：旋转动画
- 挖开矿石：scale + opacity
- 积分飘字：现有的EarningsTipView

## 注意事项

1. 保持现有的符号池机制不变
2. 保持房租支付逻辑不变
3. 保持符号选择流程不变
4. 添加充足的日志便于调试
5. 骰子结果为6且未挖格子不足6个时，挖开所有剩余格子

### To-dos

- [ ] 在SlotCell结构体中添加isMined属性
- [ ] 在GameViewModel中添加diceResult和currentRoundMinedCells属性
- [ ] 实现rollDice()方法替代spin()方法，生成1-6随机数
- [ ] 实现mineRandomCells(count:)方法，随机挖开未开矿的格子
- [ ] 修改generateSlotResults()为回合开始时生成，初始化所有格子为未挖开状态
- [ ] 修改calculateEarnings()只计算本次挖出格子的积分
- [ ] 添加resetMineState()方法，在阶段切换时重置矿石状态
- [ ] 修改startNewGame()和selectSymbol()调用新的初始化和重置方法
- [ ] 修改SlotCellView显示矿石覆盖状态和挖开动画
- [ ] 修改ControlPanel按钮为掷骰子按钮，显示骰子结果
- [ ] 测试完整游戏流程，验证掷骰子、挖矿、积分计算和状态重置